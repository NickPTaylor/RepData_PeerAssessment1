# Reproducible Research: Peer Assessment 1
NOTE: Set working directory to directory containing this file.

Load required libraries
```{r}
library(ggplot2)
library(data.table)
library(grid)
library(gridExtra)
```

## Loading and preprocessing the data
The data is loaded to a 'data table', directly from the zipped file:
```{r}
step.data <- data.table(read.csv(unz("activity.zip", "activity.csv")))
setkey(step.data, date, interval)
```
A quick check of the data is performed as follows:
```{r}
head(step.data)
dim(step.data)
```
This is consistent with expectations.

## What is mean total number of steps taken per day?
Data tables can easily be aggregated by key values.  Above, I set 'date' to be a key and then calculated the sum aggregated by this key.  From this, the ggplot library is used to plot a histogram.  Then, the mean and median total number of steps are calculated and reported.
```{r}
# aggregate total steps per day
sum.steps.per.day <- step.data[, list(sumSteps = sum(steps)), by = date]

# plot histogram of total steps per day
g1 <- ggplot(sum.steps.per.day, aes(x = sumSteps))
g1 <- g1 + geom_histogram(binwidth = 5000)
g1 <- g1 + xlab("Number of Steps in a Day")
g1 <- g1 + ylab("Frequency")
g1 <- g1 + ggtitle("Histogram of Total Number of Steps in a Day")
g1 <- g1 + xlim(0, 25000)
print(g1)

# write out results
cat(sprintf("Mean Number of Total Steps per Day: %.1f", 
                        sum.steps.per.day[, mean(sumSteps, na.rm = T)]))
cat(sprintf("Median Number of Total Steps per Day: %.1f", 
                        sum.steps.per.day[, median(sumSteps, na.rm = T)]))
```

## What is the average daily activity pattern?
Using a similar approach to above, the data table aggregate mean is computed by interval.  
```{r}
# aggregate mean steps by interval
ave.steps.per.int <- 
        step.data[, list(aveSteps = mean(steps, na.rm = T)), by = interval]

# plot time series
g2 <- ggplot(ave.steps.per.int, aes(y = aveSteps, x = interval))
g2 <- g2 + geom_line()
g2 <- g2 + xlab("Interval Identifier")
g2 <- g2 + ylab("Mean Number of Steps")
g2 <- g2 + ggtitle("Mean Number of Steps versus Interval Identifier")
print(g2)

# write out results
cat(sprintf(
        "The inteval with the maximum number of steps, on average, is: %i", 
        ave.steps.per.int[, interval[which.max(aveSteps)]]))
```

## Inputing missing values
The number of missing data is computed as follows:
```{r}
cat(sprintf(
        "The total number of missing data is: %i", 
        step.data[, sum(is.na(steps))]))
```

Here, I will 'correct' the missing data by substituting in the mean steps for that interval across all of the days of collected data:
```{r}
# correction to data
step.data[, stepsCor := 
                ifelse(
                        is.na(steps), 
                        ave.steps.per.int[interval == interval, aveSteps], 
                        steps
                )
]

# aggregate data
sum.steps.per.day <- step.data[, 
                list(sumSteps = sum(steps), sumStepsCor = sum(stepsCor)), 
                by = date]

# plot data
g3 <- ggplot(sum.steps.per.day, aes(x = sumSteps))
g3 <- g3 + geom_histogram(binwidth = 5000)
g3 <- g3 + xlab("Number of Steps in a Day")
g3 <- g3 + ylab("Frequency")
g3 <- g3 + ggtitle("Missing Data Not Corrected")
g3 <- g3 + xlim(0, 25000) + ylim(0, 40)  

g4 <- ggplot(sum.steps.per.day, aes(x = sumStepsCor))
g4 <- g4 + geom_histogram(binwidth = 5000)
g4 <- g4 + xlab("Number of Steps in a Day")
g4 <- g4 + ylab("Frequency")
g4 <- g4 + ggtitle("Missing Data Corrected")
g4 <- g4 + xlim(0, 25000) + ylim(0, 40)

grid.arrange(g3, g4, ncol = 1, 
                main = "Histograms of Total Number of Steps in a Day")

# write out results
summary(sum.steps.per.day)
```
As can be observed in the summary table, correcting the missing data has not had no effect on the mean and only a small effect on the median.  

## Are there differences in activity patterns between weekdays and weekends?
The following code identifies whether days are weekday or weekends.  Subsequently, a  plot is generated for the mean number of steps versus the interval, faceted by whether the day is during the week or at the weekend. 
```{r}
# create factor to identify whether day is week or weekend
step.data[, week.day := 
                        ifelse(weekdays(as.Date(date),T) %in% 
                        c("Sat", "Sun"), "week.end", "week.day")]

# aggregate data 
ave.steps.per.int <- 
                        step.data[, list(aveSteps = mean(stepsCor, na.rm = T)), 
                        by = c("interval", "week.day")]

# plot data
g5 <- ggplot(data = step.data, aes(x = interval, y = stepsCor))
g5 <- g5 + geom_line() 
g5 <- g5 + facet_grid(week.day ~.)
g5 <- g5 + xlab("Interval Identifier")
g5 <- g5 + ylab("Mean Number of Steps")
g5 <- g5 + ggtitle("Mean Number of Steps versus Interval Identifier")
print(g5)
```